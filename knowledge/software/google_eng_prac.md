---
layout: default
title: Google Engineering Practices
---
<h1 class="page-title">Google Engineering Practices</h1>
### Table of Content:
1. [Writing Cls](#writing-cls)
2. [Writing CL descriptions](#writing-cl-descriptions)
3. [Handling reviewers comments](#handling-reviewers-comments)

### Google Terminology:
*   **CL**: Stands for "changelist," which means one self-contained change that
    has been submitted to version control or which is undergoing code review.
    Other organizations often call this a "change" or a "patch."
*   **LGTM**: Means "Looks Good to Me." It is what a code reviewer says when
    approving a CL.

## Writing CLs

* Write small CLs!
  * **Reviewed more quickly** - easier to find a couple of minutes to check CL rather than block 30 minutes
  * **Reviewed more thoroughly** - with large CLs sometimes important points get missed or dropped
  * The less changes you make the **less likely you will intruduce bugs**
  * **Less wasted time**, if the change is rejected
  * **Easier to merge**
  * **Easier to design well** - a lot easier to polish the design and code health of a small change than it is to refine all the details of a large change.
  * **Less blocking review** - continue coding while you wait for your current CL in review
  * **Simpler to roll back**
  * **Some reviewers might rejected too large CLs**
* The right size for a CL is one self-contained change.
  * There are no hard and fast rules about how large is "too large."
  * **100 lines is usually a reasonable size for a CL**, and 1000 lines is usually too large, but it's up to the judgment of your reviewer.
  * **The number of files that a change is spread across also affects its "size."** A 200-line change in one file might be okay, but spread across 50 files it would usually be too large.
  * When in doubt, **write CLs that are smaller than you think you need to write**.
  * Reviewers rarely complain about getting CLs that are too small.
* Sometimes large changes are ok!
  * You can usually count deletion of an entire file as being just one line of change, because it doesn't take the reviewer very long to review.
  * Sometimes a large CL has been generated by an automatic refactoring tool that you trust completely, and the reviewer's job is just to sanity check and say that they really do want the change. These CLs can be larger, although some of the caveats from above (such as merging and testing) still apply.
* Another way to split up a CL is by groupings of files that will require different reviewers but are otherwise self-contained changes.
* **Refactorings should be in a separate CL from feature changes or bug fixes.**
  * For example, moving and renaming a class should be in a different CL from fixing a bug in that class.
  * Small cleanups such as fixing a local variable name can be included inside of a feature change or bug fix CL, though
* Keep related test code in the same CL (even if it increases the code line count)
  * Independent test code changes can be in seperate CLs
* Make sure that each CL is independent, so even if CLs depend on each other, any of them should not break the build seperatly
 * Otherwise you might break the build for all your fellow developers for a few minutes between your CL submissions
* Sometimes you will encounter situations where it seems like your CL has to be large. **This is very rarely true**. Authors who practice writing small CLs can almost always find a way to decompose functionality into a series of small changes.
 * Perhaps try subimitting refactor CL before
 * Talk to your teammates
 * In extremely rare situations, when all above options fail, ask the reviewer before if the large CL is fine

## Writing CL descriptions

A CL description is a public record of **what** change is being made and **why**
it was made. It will become a permanent part of our version control history, and
will possibly be read by hundreds of people other than your reviewers over the
years.

* The first line of a CL is a description of what is being done,  a complete sentence, written as though it were an order (an imperative sentence).
>"**Delete** the FizzBuzz RPC and **replace** it with the new system."
* First line should be followed by an empty line.
* The rest of the CL should be informative and list things like:
    * A brief description of the problem that's being solved
    * Why this is the best approach.
    * Any shortcomings to the approach
    * Meta-data: bug number, benchmark results and links to designs documents
* The CL shouldn't include external links, as these tend to break

#### Examples
1. Refactoring:
> Construct a Task with a TimeKeeper to use its TimeStr and Now methods.
>
> Add a Now method to Task, so the borglet() getter method can be removed (which
> was only used by OOMCandidate to call borglet's Now method). This replaces the
> methods on Borglet that delegate to a TimeKeeper.
>
> Allowing Tasks to supply Now is a step toward eliminating the dependency on
> Borglet. Eventually, collaborators that depend on getting Now from the Task
> should be changed to use a TimeKeeper directly, but this has been an
> accommodation to refactoring in small steps.
>
> Continuing the long-range goal of refactoring the Borglet Hierarch
2. Funcionality change:
> rpc: remove size limit on RPC server message freelist.
>
> Servers like FizzBuzz have very large messages and would benefit from reuse.
> Make the freelist larger, and add a goroutine that frees the freelist entries
> slowly over time, so that idle servers eventually release all freelist
> entries.

3. Small CL that needs some context
> Create a Python3 build rule for status.py.
>
> This allows consumers who are already using this as in Python3 to depend on a
> rule that is next to the original status build rule instead of somewhere in
> their own tree. It encourages new consumers to use Python3 if they can,
> instead of Python2, and significantly simplifies some automated build file
> refactoring tools being worked on currently.


## Handling reviewers comments
* When a reviewer provides a critique of your code, think of it as their attempt to help you, the codebase, and Google, rather than as a personal attack on you or your abilities.
* Never respond in anger to code review comments.That is a serious breach of professional etiquette that will live forever in the code review tool.
* If a reviewer isn't providing feedback in a way that's constructive and polite, explain this to them in **person, video call or private email**.
* If a reviewer says that **they don't understand something in your code**, your first response should be to **clarify the code itself**. If the code can't be clarified, add a code comment that explains why the code is there. If a comment seems pointless, only then should your response be an explanation in the code review tool.
* Your first question to yourself should always be, "Is the reviewer correct?"

